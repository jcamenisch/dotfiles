email=`echo 'onjthan@aamcniechsne.t' | sed -e "s/\(.\)\(.\)\(.\)/\3\1\2/g"`

export GIT_COMMITTER_NAME=Jonathan\ Camenisch
export GIT_COMMITTER_EMAIL=$email
export GIT_AUTHOR_NAME=Jonathan\ Camenisch
export GIT_AUTHOR_EMAIL=$email

safe_alias cd.g 'cd $(git rev-parse --show-toplevel)'
safe_alias g git
is_executable ga || ga () { git add $* && git status; }
safe_alias gbi  "git bisect"
safe_alias gbl  "git blame"
safe_alias gbmd 'git branch --merged | grep -v "\*" | xargs -n 1 git branch -d'
safe_alias gb   "git branch"

gbcleanup() {
  branches=$@
  [[ -z "$branches" ]] && branches=$(git branch | awk '!/\*|master/ { print $1 }')

  for b in $(echo $branches); do
    if [[ -z $(git log master..$b 2>/dev/null) ]]; then
      git push origin :$b
      git branch -d $b
    fi
  done
}

safe_alias gbd  "git branch -d"
safe_alias gbD  "git branch -D"
safe_alias gbm  "git branch -m"
# if [[ $SHELL =~ zsh ]]; then
#   gbm!() { git branch -m $1 ¡$1; }
#   gbm@() { git branch -m $1 ª$1 }
# fi
safe_alias gco  "git checkout"
safe_alias gcob "git checkout -b"
safe_alias gcm  "git commit"
safe_alias gcma "git commit --amend"
safe_alias gcmm "git commit -m"

gd() {
  switches=(`get_dashful $@`)
  args=()
  for arg in `get_dashless $@`; do
    new=$(grp $arg 2>/dev/null)
    if [[ -n "$new" ]]; then
      args+=($new)
    else
      args+= $arg
    fi
  done

  git diff ${switches[@]} $args
}

safe_alias gdc  "gd --cached"
safe_alias gdm  "gd master"
gdno() {
  gd --name-only --relative $* | uniq
}
is_executable gdmbno || gdmbno() {
  gdmb --name-only --relative $* | uniq
}

is_executable gdmb || gdmb() { # Diff a branch against its merge-base with another branch
  ref1=master
  ref2=HEAD

  [[ -n "$1" ]] && (git rev-parse "$1" 2>&1 >/dev/null || (ref1=$1 && shift))
  [[ -n "$1" ]] && (git rev-parse "$1" 2>&1 >/dev/null || (ref2=$1 && shift))

  base=`git merge-base $ref1 $ref2`

  git diff $base $ref2 $*
}

safe_alias gdw   "git diff --ignore-all-space"
safe_alias gg    "git grep"
safe_alias ggno  "git grep --name-only"
safe_alias gh    "git help"
safe_alias gl    'git log --format="%C(auto)%h %C(green)%aN%Creset %C(blue)<%ae>%n%s %C(auto)%d"'
safe_alias gl1   "gl -1"
           gl.h() { git log $(grp $1)..HEAD }
           glh.() { git log HEAD..$(grp $1) }
safe_alias glhm  "gl HEAD..master"
safe_alias glhmo "gl HEAD..origin/master"
safe_alias glmh  "gl master..HEAD"
safe_alias glomh "gl origin/master..HEAD"
safe_alias gloh  "gl origin/master..HEAD"
safe_alias glho  "gl HEAD..origin/master"
safe_alias gls   "git ls-files"
safe_alias glsg  "git ls-files | grep"
safe_alias gm    "git merge"
safe_alias gpl   "git pull"
safe_alias gplr  "git pull --rebase"
safe_alias gps   "git push"
safe_alias gpso  "git push origin"
safe_alias gpsu  "git push -u"
safe_alias gpshm "git push heroku master"
safe_alias gpspm "git push production master"
safe_alias gpssm "git push stage master"
           gr()  { git rebase $(get_dashful $@) $(grp $(get_dashless $@)) }
safe_alias grc   "git rebase --continue"

grecent() {
  declare -i default_line_count=10
  declare -i line_count=$1

  [[ $line_count == 0 ]] && line_count=$default_line_count

  git reflog | grep 'checkout: moving from' | cut -d' ' -f6 | awk '!_[$0]++' | head -$line_count
}

safe_alias grm   "git rebase master"

grp() { # git rev-parse (plus)
  switches=(`get_dashful $@`)
  args=(`get_dashless $@`)

  case ${args[1]} in
  '')
    sha=HEAD
    ;;
  o)
    sha=origin/$(git rev-parse --abbrev-ref HEAD)
    ;;
  [1-9]|[1-9][0-9])
    sha=HEAD~$args[1]
    ;;
  *)
    sha=$args[1]
  esac

  git rev-parse ${switches[@]} $sha
}

safe_alias grph  "git rev-parse HEAD"
safe_alias gruo  "git remote update origin"
safe_alias gst   "git status"
safe_alias gsh   "git stash"
safe_alias gsha  "git stash apply"
safe_alias gshl  "git stash list"
safe_alias gshp  "git stash pop"
safe_alias gsl   "git shortlog"
safe_alias gu    "git update"

if is_executable git-ftp; then
  passwd_arg=p
  [[ `uname` == "Darwin" ]] && passwd_arg=k
  alias gfp="git ftp push -$passwd_arg"
fi

is_executable gg_replace || gg_replace() {
  if [[ "$#" == "0" ]]; then
    echo 'Usage:'
    echo '  gg_replace term replacement file_mask'
    echo
    echo 'Example:'
    echo '  gg_replace cappuchino cappuccino *.html'
    echo
  else
    find=$1; shift
    replace=$1; shift

    ORIG_GLOBIGNORE=$GLOBIGNORE
    GLOBIGNORE=*.*
    
    if [[ "$#" = "0" ]]; then
      set -- ' ' $@
    fi

    while [[ "$#" -gt "0" ]]; do
      for file in `git grep -l "$find" -- $1`; do
        if [[ $(uname) = 'Darwin' ]]; then
          #for BSD flavors of sed (sorry to not check for non-Mac systems :( )
          sed -e "s/$find/$replace/g" -i '' $file
        else
          #for Linux's flavor of sed
          sed -e "s/$find/$replace/g" -i $file
        fi
      done
      shift
    done

    GLOBIGNORE=$ORIG_GLOBIGNORE
  fi
}

is_executable gg_dasherize || gg_dasherize() {
  gg_replace $1 `echo $1 | sed -e 's/_/-/g'` $2
}
